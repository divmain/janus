# Implementation Plan: `janus plan import`

This document describes the design and implementation plan for adding a `janus plan import` command that allows users to import AI-generated plan documents into Janus.

## Overview

The `plan import` command enables users to take a markdown document (typically generated by AI) and convert it into a Janus plan with associated tickets. The command:

1. Parses the document according to the Plan Format Specification
2. Creates tickets for each task defined in the document
3. Creates a plan that references those tickets
4. Handles everything atomically (all-or-nothing)

---

## 1. Plan Format Specification (PFS)

This is the canonical format that importable documents must follow. It will be output by `janus plan import-spec`.

### Basic Structure

```markdown
# Plan Title (required)

Optional description paragraph(s) providing context of the overall plan.

## Acceptance Criteria (optional)

- First criterion
- Second criterion

## Phase 1: Phase Name

Phase description. Technically optional but should be included.

### Task Title One

Task description, implementation notes, or code examples. Required.

### Task Title Two

Task description, implementation notes, or code examples. Required.

### Task Title Three

Task description, implementation notes, or code examples. Required.

## Phase 2: Another Phase Name

### Another Task
```

### Simple Plans (No Phases)

For plans without phases, tasks can be at the top level:

```markdown
# Plan Title

Plan description.

## Tasks

### Task One

Task one description.

### Task Two

Task two description.
```

Or as a simple checklist:

```markdown
# Plan Title

Plan description

## Tasks

- [ ] Task one
- [ ] Task two  
- [x] Completed task
```

### Element Reference

| Element | Format | Notes |
|---------|--------|-------|
| Plan title | `# Title` (H1) | Required, must be first heading |
| Description | Paragraphs after H1 | Optional, before first H2 |
| Acceptance criteria | `## Acceptance Criteria` | Also: `## Goals`, `## Success Criteria` |
| Phase | `## Phase N: Name` | Also: `## Stage N: Name`, `## Phase N - Name` |
| Task (H3) | `### Task Title` | Becomes ticket title |
| Task (checklist) | `- [ ] Title` or `- Title` | Alternative to H3 tasks |
| Completed task | `### Title [x]` or `- [x] Title` | Created with status: complete |
| Task body | Content after H3 | Becomes ticket description |

### Phase Numbering

Phase numbers can be:
- Numeric: `## Phase 1:`, `## Phase 2:`
- Alphanumeric: `## Phase 1a:`, `## Phase 2b:`
- Implicit: Derived from document order if not specified

### Task Content

Content between an H3 task header and the next H3/H2 becomes the ticket body. Example:

````markdown
### Add Caching Support

Implement caching in the TTS service to avoid redundant synthesis.

Key changes:
- Add cache data structure
- Modify speak() method

```rust
// Implementation hint
let cache = HashMap::new();
```

### Next Task
````

The above creates a ticket titled "Add Caching Support" with the description containing the prose and code block.

### Section Aliases

These section names are recognized (case-insensitive):

**Acceptance Criteria:** `Acceptance Criteria`, `Goals`, `Success Criteria`, `Deliverables`, `Requirements`, `Objectives`

**Tasks (simple plan):** `Tasks`, `Tickets`, `Work Items`, `Items`, `Checklist`

**Phase:** `Phase N`, `Stage N`, `Part N`, `Step N` (followed by `:` or `-`)

---

## 2. CLI Design

```
janus plan import <file>
janus plan import -                    # Read from stdin

Options:
  --dry-run              Validate and show what would be created
  --title <title>        Override title (use if duplicate detected)
  --type <type>          Ticket type for all tasks (default: task)
  --prefix <prefix>      Custom prefix for created ticket IDs
  --json                 Output result as JSON
```

Additionally:
```
janus plan import-spec        # Output the Plan Format Specification
```

---

## 3. Implementation Tasks

### 3.1 New Types (`src/plan/types.rs`)

Add structures to represent an importable plan before ticket creation:

```rust
/// Represents a parsed importable plan (before ticket creation)
pub struct ImportablePlan {
    pub title: String,
    pub description: Option<String>,
    pub acceptance_criteria: Vec<String>,
    pub phases: Vec<ImportablePhase>,   // For phased plans
    pub tasks: Vec<ImportableTask>,     // For simple plans (no phases)
}

pub struct ImportablePhase {
    pub number: String,
    pub name: String,
    pub description: Option<String>,
    pub tasks: Vec<ImportableTask>,
}

pub struct ImportableTask {
    pub title: String,
    pub body: Option<String>,
    pub is_complete: bool,
}

/// Detailed import validation errors
pub struct ImportValidationError {
    pub line: Option<usize>,
    pub message: String,
    pub hint: Option<String>,
}
```

### 3.2 Parser Functions (`src/plan/parser.rs`)

Add new functions:

| Function | Purpose |
|----------|---------|
| `parse_importable_plan(content: &str) -> Result<ImportablePlan, ImportError>` | Main entry point |
| `extract_title(doc: &AstNode) -> Option<String>` | Get H1 title |
| `extract_description(doc: &AstNode) -> Option<String>` | Get preamble paragraphs |
| `extract_acceptance_criteria(doc: &AstNode) -> Vec<String>` | Find criteria section |
| `parse_phases(doc: &AstNode) -> Vec<ImportablePhase>` | Extract phases (phased plans) |
| `parse_simple_tasks(doc: &AstNode) -> Vec<ImportableTask>` | Extract tasks (simple plans) |
| `parse_tasks_from_section(node: &AstNode) -> Vec<ImportableTask>` | H3 headers or checklist |
| `is_completed_task(text: &str) -> (String, bool)` | Check for `[x]` marker |

**Section alias constants:**

```rust
pub const ACCEPTANCE_CRITERIA_ALIASES: &[&str] = &[
    "acceptance criteria", "goals", "success criteria",
    "deliverables", "requirements", "objectives",
];

pub const TASKS_SECTION_ALIASES: &[&str] = &[
    "tasks", "tickets", "work items", "items", "checklist",
];

pub const PHASE_PATTERN: &str = r"(?i)^(phase|stage|part|step)\s+(\d+[a-z]?)\s*[-:]?\s*(.*)$";
```

### 3.3 Error Types (`src/error.rs`)

Add import-specific errors:

```rust
#[error("plan import failed: {message}")]
ImportFailed {
    message: String,
    issues: Vec<ImportValidationError>,
},

#[error("plan with title '{0}' already exists ({1})")]
DuplicatePlanTitle(String, String),  // title, existing plan ID
```

### 3.4 Command Implementation (`src/commands/plan.rs`)

Add `cmd_plan_import()`:

```rust
pub async fn cmd_plan_import(
    input: &str,           // file path or "-" for stdin
    dry_run: bool,
    title_override: Option<&str>,
    ticket_type: TicketType,
    prefix: Option<&str>,
    output_json: bool,
) -> Result<()>
```

**Logic flow:**

1. Read content from file or stdin
2. Call `parse_importable_plan(content)`
3. Apply title override if provided
4. Check for duplicate plan title
5. If `--dry-run`: display summary and exit
6. Build all tickets in memory:
   - For each phase, for each task -> `TicketMetadata`
   - Create synthetic "Verify success criteria" ticket if acceptance criteria exist
7. Write all tickets to disk
8. Build `PlanMetadata` with:
   - Generated id, uuid, created
   - Phases with newly-created ticket IDs
   - Acceptance criteria
9. Serialize and write plan
10. Output plan ID (or JSON)

### 3.5 CLI Integration (`src/main.rs`)

Add to `PlanAction` enum:

```rust
/// Import a plan from a markdown file
Import {
    /// File path (use "-" for stdin)
    file: String,

    /// Validate without creating anything
    #[arg(long)]
    dry_run: bool,

    /// Override extracted title
    #[arg(long)]
    title: Option<String>,

    /// Ticket type for created tasks (default: task)
    #[arg(long, default_value = "task")]
    r#type: TicketType,

    /// Custom prefix for ticket IDs
    #[arg(long)]
    prefix: Option<String>,

    /// Output as JSON
    #[arg(long)]
    json: bool,
},

/// Show the importable plan format specification (janus plan import-spec)
ShowImportSpec,
```

### 3.6 Format Help Command

Add `cmd_show_import_spec()` that prints the Plan Format Specification (stored as a const string).

---

## 4. Detailed Logic

### 4.1 Parsing Strategy

**Phased Plan:**
```
Document
|-- H1: Plan Title ---------------------------> plan.title
|-- Paragraphs (before first H2) -------------> plan.description
|-- H2: Acceptance Criteria ------------------> plan.acceptance_criteria[]
|   +-- List items
|-- H2: Phase 1: Name ------------------------> plan.phases[0]
|   |-- Paragraphs ---------------------------> phase.description
|   |-- H3: Task Title -----------------------> phase.tasks[0].title
|   |   +-- Content --------------------------> phase.tasks[0].body
|   +-- H3: Task Title [x] -------------------> phase.tasks[1] (is_complete: true)
|-- H2: Phase 2: Name ------------------------> plan.phases[1]
|   +-- List items (no H3s) ------------------> phase.tasks[] (from checklist)
+-- H2: Other Section ------------------------> Ignored (not a phase or known section)
```

**Simple Plan (no phases):**
```
Document
|-- H1: Plan Title ---------------------------> plan.title
|-- Paragraphs (before first H2) -------------> plan.description
|-- H2: Tasks --------------------------------> plan.tasks[] (via tasks section alias)
|   |-- H3: Task Title -----------------------> plan.tasks[0]
|   +-- H3: Task Title -----------------------> plan.tasks[1]
```

A plan is considered "phased" if it contains any H2 sections matching the phase pattern. Otherwise, it looks for a Tasks section to create a simple plan.

### 4.2 Task Extraction Priority

Within a phase section:
1. **H3 headers** take priority -> each H3 becomes a task
2. **If no H3s**, look for bullet/numbered lists -> each item becomes a task
3. **If neither**, phase has no tasks (warning)

### 4.3 Completion Marker Detection

```rust
fn is_completed_task(text: &str) -> (String, bool) {
    // H3 style: "### Task Title [x]"
    if let Some(title) = text.strip_suffix("[x]").or_else(|| text.strip_suffix("[X]")) {
        return (title.trim().to_string(), true);
    }
    // Checklist style: "- [x] Task Title"
    // (handled separately in list parsing)
    (text.to_string(), false)
}
```

### 4.4 Atomicity

All operations are built in memory first:

```rust
struct ImportTransaction {
    tickets_to_create: Vec<(TicketMetadata, String)>,  // metadata + body
    plan_to_create: (PlanMetadata, String),            // metadata + serialized
}

impl ImportTransaction {
    fn commit(self) -> Result<String> {
        // Write all tickets
        for (meta, body) in self.tickets_to_create {
            // write ticket file
        }
        // Write plan
        // return plan ID
    }
}
```

If any validation fails before `commit()`, nothing is written.

### 4.5 Duplicate Title Check

```rust
fn check_duplicate_title(title: &str) -> Result<(), JanusError> {
    let existing_plans = get_all_plans();
    for plan in existing_plans {
        if plan.title.as_deref() == Some(title) {
            return Err(JanusError::DuplicatePlanTitle(
                title.to_string(),
                plan.id.unwrap_or_default(),
            ));
        }
    }
    Ok(())
}
```

---

## 5. Output Examples

### Successful Import

```
$ janus plan import TTS-evolved.md
plan-4f2a
```

### Dry Run

```
$ janus plan import TTS-evolved.md --dry-run

Import Summary
==============

Title: TTS Unified Implementation
Description: This plan implements text-to-speech functionality...

Acceptance Criteria: 3 items
  - TTS service handles concurrent requests
  - Audio caching reduces latency by 50%
  - All existing tests pass

Phases: 6
Tasks: 18

Phase 1: Rust TTS Service Changes
  - Add Audio Cache
  - Add Cache Lookup Method
  - Update speak() Method
  - Add Cache Management

Phase 2: Command Dispatcher Changes
  - Add SpeakTextCached Variant
  - Handle New Command

... (4 more phases)

Would create:
  - 1 plan
  - 18 tickets (type: task, status: new)
  - 1 verification ticket (from acceptance criteria)

Run without --dry-run to import.
```

### Validation Error

```
$ janus plan import bad-doc.md

Error: Plan import failed

Issues found:
  x Line 1: Missing plan title (expected H1 heading)
    Hint: Add "# Your Plan Title" at the start of the document

  x Line 45: Phase "Implementation" has no tasks
    Hint: Add H3 task headers or a checklist under the phase

  x Document has no phases or tasks section
    Hint: Structure your document with "## Phase N: Name" sections
          or a "## Tasks" section for simple plans

See format specification: janus plan import-spec
```

### Duplicate Title Error

```
$ janus plan import plan.md

Error: A plan with title "TTS Implementation" already exists (plan-a1b2)

Use --title to specify a different title:
  janus plan import plan.md --title "TTS Implementation v2"
```

---

## 6. File Change Summary

| File | Action | Description |
|------|--------|-------------|
| `src/plan/types.rs` | Modify | Add `ImportablePlan`, `ImportablePhase`, `ImportableTask`, `ImportValidationError` |
| `src/plan/parser.rs` | Modify | Add `parse_importable_plan()` and helper functions, section alias constants |
| `src/plan/mod.rs` | Modify | Export new types and functions |
| `src/commands/plan.rs` | Modify | Add `cmd_plan_import()`, `cmd_show_import_spec()` |
| `src/commands/mod.rs` | Modify | Export new command functions |
| `src/main.rs` | Modify | Add `Import` and `ShowImportSpec` to `PlanAction` enum |
| `src/error.rs` | Modify | Add `ImportFailed`, `DuplicatePlanTitle` error variants |
| `tests/integration_test.rs` | Modify | Add import tests |

---

## 7. Testing Strategy

| Test Case | Description |
|-----------|-------------|
| `test_import_simple_plan` | Import a plan with `## Tasks` section (no phases) |
| `test_import_phased_plan` | Import a plan with multiple phases and H3 tasks |
| `test_import_checklist_tasks` | Import phases with `- [ ]` style tasks |
| `test_import_completed_tasks` | Verify `[x]` tasks get status: complete |
| `test_import_with_acceptance_criteria` | Verify criteria extraction and synthetic ticket |
| `test_import_dry_run` | Verify nothing is created in dry-run mode |
| `test_import_duplicate_title_error` | Verify error when title exists |
| `test_import_title_override` | Verify `--title` bypasses duplicate check |
| `test_import_invalid_format` | Verify helpful error for non-conforming docs |
| `test_import_from_stdin` | Verify `-` reads from stdin |
| `test_import_atomicity` | Verify partial failure creates nothing |

---

## 8. Design Decisions

### Why constrain the input format?

Rather than trying to parse any arbitrary AI-generated document, we define a clear "importable format" specification. This:
- Simplifies the parser (fewer edge cases)
- Provides predictable behavior
- Enables AI prompt engineering (feed the spec to AI to generate compliant docs)
- Produces better error messages

### Why H3 for tasks instead of checklists?

H3 headers allow for richer task content:
- Task title is the header
- Everything below (until next H3/H2) becomes the ticket body
- Supports code blocks, prose, sub-lists as implementation guidance

Checklists are supported as a fallback for simpler plans.

### Why create tickets automatically?

The primary use case is importing AI-generated implementation plans. These documents describe work to be done, not references to existing tickets. Creating tickets automatically enables immediate iteration without manual data entry.

### Why atomic operations?

If import fails partway through (e.g., disk full after creating 5 of 10 tickets), the user would have orphaned tickets and no plan. Atomic operations ensure either everything succeeds or nothing is created.
