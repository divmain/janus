use std::borrow::Borrow;
use std::fmt;
use std::ops::Deref;
use std::path::PathBuf;
use std::str::FromStr;

use serde::de::{self, Deserializer};
use serde::{Deserialize, Serialize};

use crate::error::JanusError;

// Re-export path functions from the paths module
pub use crate::paths::{janus_root, plans_dir, tickets_items_dir};

// =============================================================================
// Newtypes for core identity and temporal fields
// =============================================================================

/// A validated ticket ID (e.g., "j-a1b2", "task-c3d4").
///
/// Must be non-empty and match the `<prefix>-<hash>` pattern: one or more
/// alphanumeric/hyphen/underscore characters, a hyphen, then a hex hash.
///
/// Serializes transparently as a plain string in YAML/JSON for backward
/// compatibility.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize)]
#[serde(transparent)]
pub struct TicketId(String);

impl<'de> Deserialize<'de> for TicketId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        TicketId::new(&s).map_err(de::Error::custom)
    }
}

impl TicketId {
    /// Create a `TicketId` from a string, validating the format.
    pub fn new(s: impl Into<String>) -> crate::error::Result<Self> {
        let s = s.into();
        Self::validate(&s)?;
        Ok(TicketId(s))
    }

    /// Create a `TicketId` without validation.
    ///
    /// Use this only when you know the value is already valid (e.g., just
    /// generated by `generate_id_with_custom_prefix`, or read from a trusted
    /// source that has already been validated).
    pub fn new_unchecked(s: impl Into<String>) -> Self {
        TicketId(s.into())
    }

    /// Consume self and return the inner `String`.
    pub fn into_inner(self) -> String {
        self.0
    }

    fn validate(s: &str) -> crate::error::Result<()> {
        if s.is_empty() {
            return Err(JanusError::InvalidTicketIdFormat(s.to_string()));
        }
        // Must contain at least one hyphen separating prefix from hash
        if !s.contains('-') {
            return Err(JanusError::InvalidTicketIdFormat(s.to_string()));
        }
        // All characters must be alphanumeric, hyphens, or underscores
        if !s
            .chars()
            .all(|c| c.is_alphanumeric() || c == '-' || c == '_')
        {
            return Err(JanusError::InvalidTicketIdFormat(s.to_string()));
        }
        // Both prefix and hash must be non-empty
        if let Some(pos) = s.find('-') {
            let (prefix, hash) = s.split_at(pos);
            // hash includes the hyphen, so skip it
            let hash = &hash[1..];
            if prefix.is_empty() || hash.is_empty() {
                return Err(JanusError::InvalidTicketIdFormat(s.to_string()));
            }
        }
        Ok(())
    }
}

impl Deref for TicketId {
    type Target = str;
    fn deref(&self) -> &str {
        &self.0
    }
}

impl AsRef<str> for TicketId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for TicketId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl FromStr for TicketId {
    type Err = JanusError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        TicketId::new(s)
    }
}

impl From<TicketId> for String {
    fn from(id: TicketId) -> String {
        id.0
    }
}

impl PartialEq<str> for TicketId {
    fn eq(&self, other: &str) -> bool {
        self.0 == other
    }
}

impl PartialEq<String> for TicketId {
    fn eq(&self, other: &String) -> bool {
        self.0 == *other
    }
}

impl Borrow<str> for TicketId {
    fn borrow(&self) -> &str {
        &self.0
    }
}

/// A validated plan ID (e.g., "plan-a1b2").
///
/// Must be non-empty and match the `plan-<hash>` pattern.
///
/// Serializes transparently as a plain string in YAML/JSON for backward
/// compatibility.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize)]
#[serde(transparent)]
pub struct PlanId(String);

impl<'de> Deserialize<'de> for PlanId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        PlanId::new(&s).map_err(de::Error::custom)
    }
}

impl PlanId {
    /// Create a `PlanId` from a string, validating the format.
    pub fn new(s: impl Into<String>) -> crate::error::Result<Self> {
        let s = s.into();
        Self::validate(&s)?;
        Ok(PlanId(s))
    }

    /// Create a `PlanId` without validation.
    ///
    /// Use this only when you know the value is already valid (e.g., just
    /// generated by `generate_plan_id`).
    pub fn new_unchecked(s: impl Into<String>) -> Self {
        PlanId(s.into())
    }

    /// Consume self and return the inner `String`.
    pub fn into_inner(self) -> String {
        self.0
    }

    fn validate(s: &str) -> crate::error::Result<()> {
        if s.is_empty() {
            return Err(JanusError::InvalidPlanIdFormat(s.to_string()));
        }
        // Must start with "plan-"
        if !s.starts_with("plan-") {
            return Err(JanusError::InvalidPlanIdFormat(s.to_string()));
        }
        // All characters must be alphanumeric or hyphens
        if !s.chars().all(|c| c.is_alphanumeric() || c == '-') {
            return Err(JanusError::InvalidPlanIdFormat(s.to_string()));
        }
        // Hash portion after "plan-" must be non-empty
        let hash_part = &s[5..];
        if hash_part.is_empty() {
            return Err(JanusError::InvalidPlanIdFormat(s.to_string()));
        }
        Ok(())
    }
}

impl Deref for PlanId {
    type Target = str;
    fn deref(&self) -> &str {
        &self.0
    }
}

impl AsRef<str> for PlanId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for PlanId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl FromStr for PlanId {
    type Err = JanusError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        PlanId::new(s)
    }
}

impl From<PlanId> for String {
    fn from(id: PlanId) -> String {
        id.0
    }
}

impl PartialEq<str> for PlanId {
    fn eq(&self, other: &str) -> bool {
        self.0 == other
    }
}

impl PartialEq<String> for PlanId {
    fn eq(&self, other: &String) -> bool {
        self.0 == *other
    }
}

impl Borrow<str> for PlanId {
    fn borrow(&self) -> &str {
        &self.0
    }
}

/// A validated ISO 8601 / RFC 3339 timestamp string (e.g., "2024-01-01T00:00:00Z").
///
/// Validated via `jiff::Timestamp::from_str` to ensure it's a parseable timestamp.
///
/// Serializes transparently as a plain string in YAML/JSON for backward
/// compatibility.
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize)]
#[serde(transparent)]
pub struct CreatedAt(String);

impl<'de> Deserialize<'de> for CreatedAt {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        CreatedAt::new(&s).map_err(de::Error::custom)
    }
}

impl CreatedAt {
    /// Create a `CreatedAt` from a string, validating that it's a parseable timestamp.
    pub fn new(s: impl Into<String>) -> crate::error::Result<Self> {
        let s = s.into();
        Self::validate(&s)?;
        Ok(CreatedAt(s))
    }

    /// Create a `CreatedAt` without validation.
    ///
    /// Use this only when you know the value is already valid (e.g., just
    /// generated by `iso_date()`).
    pub fn new_unchecked(s: impl Into<String>) -> Self {
        CreatedAt(s.into())
    }

    /// Consume self and return the inner `String`.
    pub fn into_inner(self) -> String {
        self.0
    }

    /// Parse the inner string as a `jiff::Timestamp`.
    pub fn to_timestamp(&self) -> Option<jiff::Timestamp> {
        self.0.parse().ok()
    }

    fn validate(s: &str) -> crate::error::Result<()> {
        if s.is_empty() {
            return Err(JanusError::InvalidTimestamp(s.to_string()));
        }
        // Validate by parsing as a jiff Timestamp
        s.parse::<jiff::Timestamp>()
            .map_err(|_| JanusError::InvalidTimestamp(s.to_string()))?;
        Ok(())
    }
}

impl Deref for CreatedAt {
    type Target = str;
    fn deref(&self) -> &str {
        &self.0
    }
}

impl AsRef<str> for CreatedAt {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for CreatedAt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl FromStr for CreatedAt {
    type Err = JanusError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        CreatedAt::new(s)
    }
}

impl From<CreatedAt> for String {
    fn from(ts: CreatedAt) -> String {
        ts.0
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default, Hash)]
#[serde(rename_all = "snake_case")]
pub enum TicketStatus {
    #[default]
    New,
    Next,
    InProgress,
    Complete,
    Cancelled,
}

impl TicketStatus {
    /// All valid string representations of this enum.
    pub const ALL_STRINGS: &[&str] = &["new", "next", "in_progress", "complete", "cancelled"];

    /// Returns true if this status represents a terminal state (complete or cancelled).
    /// Terminal states indicate no further work is expected on the ticket.
    ///
    /// This method delegates to `crate::status::is_terminal()` for centralized status logic.
    pub fn is_terminal(self) -> bool {
        crate::status::is_terminal(self)
    }

    /// Returns true if this status indicates work has not yet started (new or next).
    /// These are pre-work states where the ticket is queued but not actively being worked on.
    ///
    /// This method delegates to `crate::status::is_not_started()` for centralized status logic.
    pub fn is_not_started(self) -> bool {
        crate::status::is_not_started(self)
    }
}

enum_display_fromstr!(
    TicketStatus,
    JanusError::InvalidStatus,
    {
        New => "new",
        Next => "next",
        InProgress => "in_progress",
        Complete => "complete",
        Cancelled => "cancelled",
    }
);

pub const VALID_STATUSES: &[&str] = TicketStatus::ALL_STRINGS;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "lowercase")]
pub enum TicketType {
    Bug,
    Feature,
    #[default]
    Task,
    Epic,
    Chore,
}

impl TicketType {
    /// All valid string representations of this enum.
    pub const ALL_STRINGS: &[&str] = &["bug", "feature", "task", "epic", "chore"];
}

enum_display_fromstr!(
    TicketType,
    JanusError::InvalidTicketType,
    {
        Bug => "bug",
        Feature => "feature",
        Task => "task",
        Epic => "epic",
        Chore => "chore",
    }
);

pub const VALID_TYPES: &[&str] = TicketType::ALL_STRINGS;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum EntityType {
    Ticket,
    Plan,
    Cache,
}

enum_display_fromstr!(
    EntityType,
    JanusError::InvalidEntityType,
    {
        Ticket => "ticket",
        Plan => "plan",
        Cache => "cache",
    }
);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Default)]
pub enum TicketPriority {
    #[serde(rename = "0")]
    P0,
    #[serde(rename = "1")]
    P1,
    #[default]
    #[serde(rename = "2")]
    P2,
    #[serde(rename = "3")]
    P3,
    #[serde(rename = "4")]
    P4,
}

impl serde::Serialize for TicketPriority {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_u8(self.as_num())
    }
}

impl TicketPriority {
    /// All valid string representations of this enum.
    pub const ALL_STRINGS: &[&str] = &["0", "1", "2", "3", "4"];

    pub fn as_num(&self) -> u8 {
        match self {
            TicketPriority::P0 => 0,
            TicketPriority::P1 => 1,
            TicketPriority::P2 => 2,
            TicketPriority::P3 => 3,
            TicketPriority::P4 => 4,
        }
    }
}

enum_display_fromstr!(
    TicketPriority,
    JanusError::InvalidPriority,
    {
        P0 => "0",
        P1 => "1",
        P2 => "2",
        P3 => "3",
        P4 => "4",
    }
);

pub const VALID_PRIORITIES: &[&str] = TicketPriority::ALL_STRINGS;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TicketSize {
    XSmall,
    Small,
    Medium,
    Large,
    XLarge,
}

impl TicketSize {
    /// All valid string representations of this enum.
    pub const ALL_STRINGS: &[&str] = &["xsmall", "small", "medium", "large", "xlarge"];

    pub fn ordinal(&self) -> u8 {
        match self {
            Self::XSmall => 0,
            Self::Small => 1,
            Self::Medium => 2,
            Self::Large => 3,
            Self::XLarge => 4,
        }
    }

    pub const ALL: &'static [TicketSize] = &[
        Self::XSmall,
        Self::Small,
        Self::Medium,
        Self::Large,
        Self::XLarge,
    ];
}

impl std::fmt::Display for TicketSize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::XSmall => write!(f, "xsmall"),
            Self::Small => write!(f, "small"),
            Self::Medium => write!(f, "medium"),
            Self::Large => write!(f, "large"),
            Self::XLarge => write!(f, "xlarge"),
        }
    }
}

impl FromStr for TicketSize {
    type Err = JanusError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "xsmall" | "xs" => Ok(TicketSize::XSmall),
            "small" | "s" => Ok(TicketSize::Small),
            "medium" | "m" => Ok(TicketSize::Medium),
            "large" | "l" => Ok(TicketSize::Large),
            "xlarge" | "xl" => Ok(TicketSize::XLarge),
            _ => Err(JanusError::InvalidSize(s.to_string())),
        }
    }
}

pub const VALID_SIZES: &[&str] = TicketSize::ALL_STRINGS;

/// Default priority value (P2 - normal priority)
pub const DEFAULT_PRIORITY: u8 = 2;

/// Default priority as a string for CLI arguments
pub const DEFAULT_PRIORITY_STR: &str = "2";

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TicketField {
    Id,
    Uuid,
    Status,
    Deps,
    Links,
    Created,
    Type,
    Priority,
    Size,
    ExternalRef,
    Remote,
    Parent,
    SpawnedFrom,
    SpawnContext,
    Depth,
    Triaged,
}

/// Enum for array field names to provide compile-time type safety.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ArrayField {
    Deps,
    Links,
}

impl ArrayField {
    pub fn as_str(&self) -> &'static str {
        match self {
            ArrayField::Deps => "deps",
            ArrayField::Links => "links",
        }
    }
}

impl std::str::FromStr for ArrayField {
    type Err = JanusError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "deps" => Ok(ArrayField::Deps),
            "links" => Ok(ArrayField::Links),
            _ => Err(JanusError::UnknownArrayField(s.to_string())),
        }
    }
}

impl TicketField {
    pub fn is_immutable(&self) -> bool {
        matches!(self, TicketField::Id | TicketField::Uuid)
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            TicketField::Id => "id",
            TicketField::Uuid => "uuid",
            TicketField::Status => "status",
            TicketField::Deps => "deps",
            TicketField::Links => "links",
            TicketField::Created => "created",
            TicketField::Type => "type",
            TicketField::Priority => "priority",
            TicketField::Size => "size",
            TicketField::ExternalRef => "external-ref",
            TicketField::Remote => "remote",
            TicketField::Parent => "parent",
            TicketField::SpawnedFrom => "spawned-from",
            TicketField::SpawnContext => "spawn-context",
            TicketField::Depth => "depth",
            TicketField::Triaged => "triaged",
        }
    }

    pub fn all() -> &'static [Self] {
        use TicketField::*;
        &[
            Id,
            Uuid,
            Status,
            Deps,
            Links,
            Created,
            Type,
            Priority,
            Size,
            ExternalRef,
            Remote,
            Parent,
            SpawnedFrom,
            SpawnContext,
            Depth,
            Triaged,
        ]
    }
}

impl std::fmt::Display for TicketField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for TicketField {
    type Err = crate::error::JanusError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let s_lower = s.to_lowercase();
        TicketField::all()
            .iter()
            .find(|f| f.as_str() == s_lower)
            .copied()
            .ok_or_else(|| JanusError::InvalidFieldName(s.to_string()))
    }
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TicketMetadata {
    // --- Persisted YAML fields ---
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<TicketId>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub uuid: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<TicketStatus>,

    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub deps: Vec<String>,

    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub links: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<CreatedAt>,

    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub ticket_type: Option<TicketType>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<TicketPriority>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<TicketSize>,

    #[serde(rename = "external-ref", skip_serializing_if = "Option::is_none")]
    pub external_ref: Option<String>,

    /// Remote issue reference (e.g., "github:owner/repo/123" or "linear:org/PROJ-123")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<TicketId>,

    /// ID of the parent ticket that spawned this one (decomposition provenance)
    #[serde(rename = "spawned-from", skip_serializing_if = "Option::is_none")]
    pub spawned_from: Option<TicketId>,

    /// Brief context explaining why this ticket was created from the parent
    #[serde(rename = "spawn-context", skip_serializing_if = "Option::is_none")]
    pub spawn_context: Option<String>,

    /// Auto-computed decomposition depth (0 = root ticket, parent.depth + 1 otherwise)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub depth: Option<u32>,

    /// Whether the ticket has been triaged (reviewed and assessed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triaged: Option<bool>,

    // --- Runtime-only fields ---
    #[serde(skip)]
    pub title: Option<String>,

    #[serde(skip)]
    pub file_path: Option<PathBuf>,

    /// Completion summary extracted from `## Completion Summary` section in body
    /// Only meaningful for tickets with status: complete
    #[serde(skip)]
    pub completion_summary: Option<String>,

    /// Ticket body content (only populated during store initialization, not persisted to YAML)
    #[serde(skip)]
    pub body: Option<String>,
}

impl TicketData for TicketMetadata {
    fn id(&self) -> Option<&str> {
        self.id.as_ref().map(|id| id.as_ref())
    }

    fn title(&self) -> Option<&str> {
        self.title.as_deref()
    }

    fn priority_num(&self) -> u8 {
        self.priority
            .map(|p| p.as_num())
            .unwrap_or(DEFAULT_PRIORITY)
    }

    fn compute_depth(&self) -> u32 {
        self.depth.unwrap_or_else(|| {
            // If no explicit depth, infer: if no spawned_from, it's depth 0
            if self.spawned_from.is_none() { 0 } else { 1 }
        })
    }
}

impl TicketMetadata {
    /// Get the ticket ID as a String, returning None if no ID exists
    pub fn id_str(&self) -> Option<String> {
        self.id.as_ref().map(|id| id.to_string())
    }

    /// Parse the `created` field as a jiff::Timestamp.
    ///
    /// Returns `Some(Timestamp)` if the field is present and valid,
    /// `None` if the field is missing or cannot be parsed.
    pub fn created_timestamp(&self) -> Option<jiff::Timestamp> {
        self.created.as_ref().and_then(|c| c.to_timestamp())
    }

    /// Get the item UUID
    pub fn uuid(&self) -> Option<&str> {
        self.uuid.as_deref()
    }

    /// Get the file path
    pub fn file_path(&self) -> Option<&PathBuf> {
        self.file_path.as_ref()
    }

    /// Get the item type
    pub fn item_type(&self) -> EntityType {
        EntityType::Ticket
    }
}

/// Shared ticket data interface for types that contain ticket metadata.
///
/// This trait abstracts common access patterns for both `TicketMetadata`
/// and `TicketSummary`, avoiding method duplication.
pub trait TicketData {
    /// Get the ticket ID as a string slice
    fn id(&self) -> Option<&str>;

    /// Get the ticket title
    fn title(&self) -> Option<&str>;

    /// Get priority as a number for sorting (defaults to DEFAULT_PRIORITY)
    fn priority_num(&self) -> u8;

    /// Compute the effective depth of this ticket
    fn compute_depth(&self) -> u32;
}

/// Lightweight ticket summary without the full markdown body.
///
/// Contains all metadata fields needed for listing, filtering, and display
/// but omits the potentially large `body` field and `file_path` to reduce
/// clone overhead in query and search operations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TicketSummary {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<TicketId>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub uuid: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<TicketStatus>,

    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub deps: Vec<String>,

    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub links: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<CreatedAt>,

    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub ticket_type: Option<TicketType>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<TicketPriority>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<TicketSize>,

    #[serde(rename = "external-ref", skip_serializing_if = "Option::is_none")]
    pub external_ref: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<TicketId>,

    #[serde(rename = "spawned-from", skip_serializing_if = "Option::is_none")]
    pub spawned_from: Option<TicketId>,

    #[serde(rename = "spawn-context", skip_serializing_if = "Option::is_none")]
    pub spawn_context: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub depth: Option<u32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub triaged: Option<bool>,

    #[serde(skip)]
    pub title: Option<String>,

    #[serde(skip)]
    pub completion_summary: Option<String>,
}

impl TicketData for TicketSummary {
    fn id(&self) -> Option<&str> {
        self.id.as_ref().map(|id| id.as_ref())
    }

    fn title(&self) -> Option<&str> {
        self.title.as_deref()
    }

    fn priority_num(&self) -> u8 {
        self.priority
            .map(|p| p.as_num())
            .unwrap_or(DEFAULT_PRIORITY)
    }

    fn compute_depth(&self) -> u32 {
        self.depth
            .unwrap_or_else(|| if self.spawned_from.is_none() { 0 } else { 1 })
    }
}

impl From<&TicketMetadata> for TicketSummary {
    fn from(meta: &TicketMetadata) -> Self {
        TicketSummary {
            id: meta.id.clone(),
            uuid: meta.uuid.clone(),
            status: meta.status,
            deps: meta.deps.clone(),
            links: meta.links.clone(),
            created: meta.created.clone(),
            ticket_type: meta.ticket_type,
            priority: meta.priority,
            size: meta.size,
            external_ref: meta.external_ref.clone(),
            remote: meta.remote.clone(),
            parent: meta.parent.clone(),
            spawned_from: meta.spawned_from.clone(),
            spawn_context: meta.spawn_context.clone(),
            depth: meta.depth,
            triaged: meta.triaged,
            title: meta.title.clone(),
            completion_summary: meta.completion_summary.clone(),
        }
    }
}

/// Helper struct for tickets with computed blockers
#[derive(Debug, Clone)]
pub struct TicketWithBlockers {
    pub metadata: TicketMetadata,
    pub open_blockers: Vec<String>,
}

pub fn validate_field_name(field: &str, operation: &str) -> crate::error::Result<()> {
    let parsed = field.parse::<TicketField>()?;

    if parsed.is_immutable() {
        return Err(JanusError::ImmutableField {
            field: parsed.to_string(),
            operation: operation.to_string(),
        });
    }

    Ok(())
}

/// Generic result type for loading items from disk, including both successes and failures.
///
/// This type is used as the basis for `TicketLoadResult` and `PlanLoadResult` via type aliases.
#[derive(Debug, Clone)]
pub struct LoadResult<T> {
    /// Successfully loaded items
    pub items: Vec<T>,
    /// Failed files with their error messages (filename, error)
    pub failed: Vec<(String, String)>,
}

impl<T> LoadResult<T> {
    /// Create a new empty result
    pub fn new() -> Self {
        LoadResult {
            items: Vec::new(),
            failed: Vec::new(),
        }
    }

    /// Add a successfully loaded item
    pub fn add_item(&mut self, item: T) {
        self.items.push(item);
    }

    /// Add a failed file with its error
    pub fn add_failure(&mut self, filename: impl Into<String>, error: impl Into<String>) {
        self.failed.push((filename.into(), error.into()));
    }

    /// Check if any failures occurred
    pub fn has_failures(&self) -> bool {
        !self.failed.is_empty()
    }

    /// Get the number of successfully loaded items
    pub fn success_count(&self) -> usize {
        self.items.len()
    }

    /// Get the number of failed files
    pub fn failure_count(&self) -> usize {
        self.failed.len()
    }

    /// Get just the items, ignoring failures
    pub fn into_items(self) -> Vec<T> {
        self.items
    }
}

impl<T> Default for LoadResult<T> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ticket_status_is_terminal() {
        assert!(TicketStatus::Complete.is_terminal());
        assert!(TicketStatus::Cancelled.is_terminal());
        assert!(!TicketStatus::New.is_terminal());
        assert!(!TicketStatus::Next.is_terminal());
        assert!(!TicketStatus::InProgress.is_terminal());
    }

    #[test]
    fn test_ticket_status_is_not_started() {
        assert!(TicketStatus::New.is_not_started());
        assert!(TicketStatus::Next.is_not_started());
        assert!(!TicketStatus::InProgress.is_not_started());
        assert!(!TicketStatus::Complete.is_not_started());
        assert!(!TicketStatus::Cancelled.is_not_started());
    }

    #[test]
    fn test_ticket_status_from_str_case_insensitive() {
        // Lowercase
        assert_eq!("new".parse::<TicketStatus>().unwrap(), TicketStatus::New);
        assert_eq!(
            "in_progress".parse::<TicketStatus>().unwrap(),
            TicketStatus::InProgress
        );

        // Uppercase
        assert_eq!("NEW".parse::<TicketStatus>().unwrap(), TicketStatus::New);
        assert_eq!("NEXT".parse::<TicketStatus>().unwrap(), TicketStatus::Next);
        assert_eq!(
            "IN_PROGRESS".parse::<TicketStatus>().unwrap(),
            TicketStatus::InProgress
        );
        assert_eq!(
            "COMPLETE".parse::<TicketStatus>().unwrap(),
            TicketStatus::Complete
        );
        assert_eq!(
            "CANCELLED".parse::<TicketStatus>().unwrap(),
            TicketStatus::Cancelled
        );

        // Mixed case
        assert_eq!("New".parse::<TicketStatus>().unwrap(), TicketStatus::New);
        assert_eq!("Next".parse::<TicketStatus>().unwrap(), TicketStatus::Next);
        assert_eq!(
            "In_Progress".parse::<TicketStatus>().unwrap(),
            TicketStatus::InProgress
        );

        // Invalid
        assert!("invalid".parse::<TicketStatus>().is_err());
        assert!("".parse::<TicketStatus>().is_err());
    }

    #[test]
    fn test_ticket_type_from_str_case_insensitive() {
        // Lowercase
        assert_eq!("bug".parse::<TicketType>().unwrap(), TicketType::Bug);
        assert_eq!(
            "feature".parse::<TicketType>().unwrap(),
            TicketType::Feature
        );
        assert_eq!("task".parse::<TicketType>().unwrap(), TicketType::Task);
        assert_eq!("epic".parse::<TicketType>().unwrap(), TicketType::Epic);
        assert_eq!("chore".parse::<TicketType>().unwrap(), TicketType::Chore);

        // Uppercase
        assert_eq!("BUG".parse::<TicketType>().unwrap(), TicketType::Bug);
        assert_eq!(
            "FEATURE".parse::<TicketType>().unwrap(),
            TicketType::Feature
        );
        assert_eq!("TASK".parse::<TicketType>().unwrap(), TicketType::Task);
        assert_eq!("EPIC".parse::<TicketType>().unwrap(), TicketType::Epic);
        assert_eq!("CHORE".parse::<TicketType>().unwrap(), TicketType::Chore);

        // Mixed case
        assert_eq!("Bug".parse::<TicketType>().unwrap(), TicketType::Bug);
        assert_eq!(
            "Feature".parse::<TicketType>().unwrap(),
            TicketType::Feature
        );
        assert_eq!("Task".parse::<TicketType>().unwrap(), TicketType::Task);

        // Invalid
        assert!("invalid".parse::<TicketType>().is_err());
        assert!("".parse::<TicketType>().is_err());
    }

    #[test]
    fn test_ticket_priority_from_str() {
        // Valid numeric strings
        assert_eq!("0".parse::<TicketPriority>().unwrap(), TicketPriority::P0);
        assert_eq!("1".parse::<TicketPriority>().unwrap(), TicketPriority::P1);
        assert_eq!("2".parse::<TicketPriority>().unwrap(), TicketPriority::P2);
        assert_eq!("3".parse::<TicketPriority>().unwrap(), TicketPriority::P3);
        assert_eq!("4".parse::<TicketPriority>().unwrap(), TicketPriority::P4);

        // Invalid
        assert!("5".parse::<TicketPriority>().is_err());
        assert!("-1".parse::<TicketPriority>().is_err());
        assert!("p0".parse::<TicketPriority>().is_err());
        assert!("P0".parse::<TicketPriority>().is_err());
        assert!("".parse::<TicketPriority>().is_err());
    }

    #[test]
    fn test_spawning_metadata_fields_exist() {
        // Verify spawning metadata fields are valid TicketField variants
        assert!("spawned-from".parse::<TicketField>().is_ok());
        assert!("spawn-context".parse::<TicketField>().is_ok());
        assert!("depth".parse::<TicketField>().is_ok());
    }

    #[test]
    fn test_ticket_metadata_default_spawning_fields_none() {
        // Verify spawning fields default to None
        let metadata = TicketMetadata::default();
        assert!(metadata.spawned_from.is_none());
        assert!(metadata.spawn_context.is_none());
        assert!(metadata.depth.is_none());
    }

    #[test]
    fn test_ticket_metadata_spawning_fields_serialization() {
        use serde_yaml_ng as yaml;

        // Test that spawning fields serialize correctly when present
        let metadata = TicketMetadata {
            id: Some(TicketId::new_unchecked("j-test")),
            spawned_from: Some(TicketId::new_unchecked("j-parent")),
            spawn_context: Some("Test context".to_string()),
            depth: Some(2),
            ..Default::default()
        };

        let yaml_str = yaml::to_string(&metadata).unwrap();
        assert!(yaml_str.contains("spawned-from: j-parent"));
        assert!(yaml_str.contains("spawn-context: Test context"));
        assert!(yaml_str.contains("depth: 2"));
    }

    #[test]
    fn test_ticket_metadata_spawning_fields_skip_serialization_when_none() {
        use serde_yaml_ng as yaml;

        // Test that spawning fields are skipped when None
        let metadata = TicketMetadata {
            id: Some(TicketId::new_unchecked("j-test")),
            ..Default::default()
        };

        let yaml_str = yaml::to_string(&metadata).unwrap();
        assert!(!yaml_str.contains("spawned-from"));
        assert!(!yaml_str.contains("spawn-context"));
        assert!(!yaml_str.contains("depth"));
    }

    #[test]
    fn test_ticket_metadata_spawning_fields_deserialization() {
        use serde_yaml_ng as yaml;

        // Test that spawning fields deserialize correctly
        let yaml_str = r#"
id: j-test
spawned-from: j-parent
spawn-context: Auth implementation requires OAuth setup first
depth: 2
"#;
        let metadata: TicketMetadata = yaml::from_str(yaml_str).unwrap();
        assert_eq!(metadata.id.as_deref(), Some("j-test"));
        assert_eq!(metadata.spawned_from.as_deref(), Some("j-parent"));
        assert_eq!(
            metadata.spawn_context,
            Some("Auth implementation requires OAuth setup first".to_string())
        );
        assert_eq!(metadata.depth, Some(2));
    }

    #[test]
    fn test_ticket_metadata_spawning_fields_deserialization_missing() {
        use serde_yaml_ng as yaml;

        // Test that missing spawning fields deserialize as None
        let yaml_str = r#"
id: j-test
status: new
"#;
        let metadata: TicketMetadata = yaml::from_str(yaml_str).unwrap();
        assert_eq!(metadata.id.as_deref(), Some("j-test"));
        assert!(metadata.spawned_from.is_none());
        assert!(metadata.spawn_context.is_none());
        assert!(metadata.depth.is_none());
    }

    #[test]
    fn test_validate_field_name_valid() {
        assert!(validate_field_name("status", "update").is_ok());
        assert!(validate_field_name("priority", "update").is_ok());
        assert!(validate_field_name("type", "update").is_ok());
    }

    #[test]
    fn test_validate_field_name_invalid() {
        let result = validate_field_name("unknown_field", "update");
        assert!(result.is_err());
        match result.unwrap_err() {
            JanusError::InvalidFieldName(field) => {
                assert_eq!(field, "unknown_field");
            }
            _ => panic!("Expected InvalidFieldName error"),
        }
    }

    #[test]
    fn test_validate_field_name_immutable_id() {
        let result = validate_field_name("id", "update");
        assert!(result.is_err());
        match result.unwrap_err() {
            JanusError::ImmutableField { field, operation } => {
                assert_eq!(field, "id");
                assert_eq!(operation, "update");
            }
            other => panic!("Expected ImmutableField error, got: {other:?}"),
        }
    }

    #[test]
    fn test_validate_field_name_immutable_uuid() {
        let result = validate_field_name("uuid", "update");
        assert!(result.is_err());
        match result.unwrap_err() {
            JanusError::ImmutableField { field, operation } => {
                assert_eq!(field, "uuid");
                assert_eq!(operation, "update");
            }
            other => panic!("Expected ImmutableField error, got: {other:?}"),
        }
    }

    #[test]
    fn test_validate_field_name_remove_immutable() {
        let result = validate_field_name("id", "remove");
        assert!(result.is_err());
        match result.unwrap_err() {
            JanusError::ImmutableField { field, operation } => {
                assert_eq!(field, "id");
                assert_eq!(operation, "remove");
            }
            other => panic!("Expected ImmutableField error, got: {other:?}"),
        }
    }

    #[test]
    fn test_ticket_field_from_str_valid() {
        assert_eq!(TicketField::from_str("id").unwrap(), TicketField::Id);
        assert_eq!(TicketField::from_str("uuid").unwrap(), TicketField::Uuid);
        assert_eq!(
            TicketField::from_str("status").unwrap(),
            TicketField::Status
        );
        assert_eq!(TicketField::from_str("deps").unwrap(), TicketField::Deps);
        assert_eq!(TicketField::from_str("type").unwrap(), TicketField::Type);
        assert_eq!(
            TicketField::from_str("spawned-from").unwrap(),
            TicketField::SpawnedFrom
        );
        assert_eq!(
            TicketField::from_str("spawn-context").unwrap(),
            TicketField::SpawnContext
        );
    }

    #[test]
    fn test_ticket_field_from_str_invalid() {
        assert!(TicketField::from_str("invalid").is_err());
        assert!(TicketField::from_str("").is_err());
        assert_eq!(TicketField::from_str("ID").unwrap(), TicketField::Id);
    }

    #[test]
    fn test_ticket_field_is_immutable() {
        assert!(TicketField::Id.is_immutable());
        assert!(TicketField::Uuid.is_immutable());
        assert!(!TicketField::Status.is_immutable());
        assert!(!TicketField::Priority.is_immutable());
        assert!(!TicketField::SpawnedFrom.is_immutable());
    }

    #[test]
    fn test_ticket_field_as_str() {
        assert_eq!(TicketField::Id.as_str(), "id");
        assert_eq!(TicketField::Uuid.as_str(), "uuid");
        assert_eq!(TicketField::Status.as_str(), "status");
        assert_eq!(TicketField::SpawnedFrom.as_str(), "spawned-from");
        assert_eq!(TicketField::SpawnContext.as_str(), "spawn-context");
    }

    #[test]
    fn test_ticket_field_display() {
        assert_eq!(format!("{}", TicketField::Id), "id");
        assert_eq!(format!("{}", TicketField::SpawnedFrom), "spawned-from");
    }

    #[test]
    fn test_validate_field_name_uses_strict_enum() {
        let valid_fields = TicketField::all();
        assert!(!valid_fields.is_empty());

        for field in valid_fields {
            if !field.is_immutable() {
                assert!(
                    validate_field_name(field.as_str(), "update").is_ok(),
                    "Valid mutable field '{field}' should be accepted"
                );
            } else {
                let result = validate_field_name(field.as_str(), "update");
                assert!(
                    result.is_err(),
                    "Immutable field '{field}' should be rejected for update"
                );
            }
        }
    }

    #[test]
    fn test_ticket_size_display() {
        assert_eq!(TicketSize::XSmall.to_string(), "xsmall");
        assert_eq!(TicketSize::Small.to_string(), "small");
        assert_eq!(TicketSize::Medium.to_string(), "medium");
        assert_eq!(TicketSize::Large.to_string(), "large");
        assert_eq!(TicketSize::XLarge.to_string(), "xlarge");
    }

    #[test]
    fn test_ticket_size_from_str() {
        // Full names (lowercase)
        assert_eq!("xsmall".parse::<TicketSize>().unwrap(), TicketSize::XSmall);
        assert_eq!("small".parse::<TicketSize>().unwrap(), TicketSize::Small);
        assert_eq!("medium".parse::<TicketSize>().unwrap(), TicketSize::Medium);
        assert_eq!("large".parse::<TicketSize>().unwrap(), TicketSize::Large);
        assert_eq!("xlarge".parse::<TicketSize>().unwrap(), TicketSize::XLarge);

        // Full names (uppercase)
        assert_eq!("XSMALL".parse::<TicketSize>().unwrap(), TicketSize::XSmall);
        assert_eq!("SMALL".parse::<TicketSize>().unwrap(), TicketSize::Small);
        assert_eq!("MEDIUM".parse::<TicketSize>().unwrap(), TicketSize::Medium);
        assert_eq!("LARGE".parse::<TicketSize>().unwrap(), TicketSize::Large);
        assert_eq!("XLARGE".parse::<TicketSize>().unwrap(), TicketSize::XLarge);

        // Full names (mixed case)
        assert_eq!("XSmall".parse::<TicketSize>().unwrap(), TicketSize::XSmall);
        assert_eq!("Small".parse::<TicketSize>().unwrap(), TicketSize::Small);
        assert_eq!("Medium".parse::<TicketSize>().unwrap(), TicketSize::Medium);

        // Aliases
        assert_eq!("xs".parse::<TicketSize>().unwrap(), TicketSize::XSmall);
        assert_eq!("s".parse::<TicketSize>().unwrap(), TicketSize::Small);
        assert_eq!("m".parse::<TicketSize>().unwrap(), TicketSize::Medium);
        assert_eq!("l".parse::<TicketSize>().unwrap(), TicketSize::Large);
        assert_eq!("xl".parse::<TicketSize>().unwrap(), TicketSize::XLarge);

        // Aliases (uppercase)
        assert_eq!("XS".parse::<TicketSize>().unwrap(), TicketSize::XSmall);
        assert_eq!("S".parse::<TicketSize>().unwrap(), TicketSize::Small);
        assert_eq!("M".parse::<TicketSize>().unwrap(), TicketSize::Medium);
        assert_eq!("L".parse::<TicketSize>().unwrap(), TicketSize::Large);
        assert_eq!("XL".parse::<TicketSize>().unwrap(), TicketSize::XLarge);

        // Invalid values
        assert!("invalid".parse::<TicketSize>().is_err());
        assert!("tiny".parse::<TicketSize>().is_err());
        assert!("huge".parse::<TicketSize>().is_err());
        assert!("".parse::<TicketSize>().is_err());
    }

    #[test]
    fn test_ticket_size_ordering() {
        // Verify ordinal values are in correct order
        assert!(TicketSize::XSmall.ordinal() < TicketSize::Small.ordinal());
        assert!(TicketSize::Small.ordinal() < TicketSize::Medium.ordinal());
        assert!(TicketSize::Medium.ordinal() < TicketSize::Large.ordinal());
        assert!(TicketSize::Large.ordinal() < TicketSize::XLarge.ordinal());

        // Verify exact ordinal values
        assert_eq!(TicketSize::XSmall.ordinal(), 0);
        assert_eq!(TicketSize::Small.ordinal(), 1);
        assert_eq!(TicketSize::Medium.ordinal(), 2);
        assert_eq!(TicketSize::Large.ordinal(), 3);
        assert_eq!(TicketSize::XLarge.ordinal(), 4);
    }

    #[test]
    fn test_ticket_size_serde_json() {
        // Test JSON serialization
        let size = TicketSize::Medium;
        let json = serde_json::to_string(&size).unwrap();
        assert_eq!(json, "\"medium\"");

        // Test JSON deserialization
        let deserialized: TicketSize = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, size);

        // Test all variants roundtrip
        for size in TicketSize::ALL {
            let json = serde_json::to_string(size).unwrap();
            let deserialized: TicketSize = serde_json::from_str(&json).unwrap();
            assert_eq!(*size, deserialized);
        }
    }

    #[test]
    fn test_ticket_size_serde_yaml() {
        use serde_yaml_ng as yaml;

        // Test YAML serialization
        let size = TicketSize::Large;
        let yaml_str = yaml::to_string(&size).unwrap();
        assert!(yaml_str.contains("large"));

        // Test YAML deserialization
        let deserialized: TicketSize = yaml::from_str(&yaml_str).unwrap();
        assert_eq!(deserialized, size);

        // Test all variants roundtrip
        for size in TicketSize::ALL {
            let yaml_str = yaml::to_string(size).unwrap();
            let deserialized: TicketSize = yaml::from_str(&yaml_str).unwrap();
            assert_eq!(*size, deserialized);
        }
    }

    #[test]
    fn test_ticket_size_in_metadata() {
        use serde_yaml_ng as yaml;

        // Test that size field serializes correctly when present
        let metadata = TicketMetadata {
            id: Some(TicketId::new_unchecked("j-test")),
            size: Some(TicketSize::Medium),
            ..Default::default()
        };

        let yaml_str = yaml::to_string(&metadata).unwrap();
        assert!(yaml_str.contains("size: medium"));

        // Test that size field is skipped when None
        let metadata_no_size = TicketMetadata {
            id: Some(TicketId::new_unchecked("j-test")),
            size: None,
            ..Default::default()
        };

        let yaml_str = yaml::to_string(&metadata_no_size).unwrap();
        assert!(!yaml_str.contains("size"));

        // Test deserialization
        let yaml_input = r#"
id: j-test
size: large
"#;
        let metadata: TicketMetadata = yaml::from_str(yaml_input).unwrap();
        assert_eq!(metadata.size, Some(TicketSize::Large));
    }

    #[test]
    fn test_ticket_field_size() {
        assert_eq!(TicketField::Size.as_str(), "size");
        assert!(TicketField::all().contains(&TicketField::Size));
        assert!(!TicketField::Size.is_immutable());
    }
}
